<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kirinpeng</title>
  
  <subtitle>kirinpeng的blog</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-08T16:40:57.361Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>kirinpeng</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何根据系统日志定位进程crash原因</title>
    <link href="http://example.com/2022/05/08/%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E5%AE%9A%E4%BD%8D%E8%BF%9B%E7%A8%8Bcrash%E5%8E%9F%E5%9B%A0/"/>
    <id>http://example.com/2022/05/08/%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97%E5%AE%9A%E4%BD%8D%E8%BF%9B%E7%A8%8Bcrash%E5%8E%9F%E5%9B%A0/</id>
    <published>2022-05-08T15:59:21.000Z</published>
    <updated>2022-05-08T16:40:57.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>使用cpp开发的服务，当服务进程出现crash时，如果我们在服务启动前，开启了<code>ulimit -c unlimited</code>，那么我们的进程会留下core文件，通过执行<code>gdb [exec file] [core file]</code>指令，可以追踪到进程的crash位置，方便我们排查问题。<br>但是在某些情况下，例如我们的服务作为基础组件，部署在用户的机器上，为了防止core文件把机器硬盘打满，在进程启动前，会执行<code>ulimit -c 0</code>来禁止core文件的产生，在这种情况下，如果服务进程出现了crash，我们是无法通过core文件来定位问题的。<br>那么，针对这种场景，我们有解决办法吗？</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>解决办法之一，就是结合系统日志来进行定位。<br><code>/var/log</code>是linux系统日志的目录，<code>/var/log/messages</code>为系统报错日志，当我们的进程出现crash时，会在这个文件中留下系统日志。<br>我们以这个cpp程序为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span> &#123;</span></span><br><span class="line">  string info;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Info* ptr = <span class="literal">NULL</span>;</span><br><span class="line">  cout &lt;&lt; ptr-&gt;info &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于访问了空指针，毫无疑问，当程序运行到<code>cout &lt;&lt; ptr-&gt;info &lt;&lt; endl;</code>时，会出现<code>Segmentation fault</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./segfault </span><br><span class="line">Segmentation fault</span><br></pre></td></tr></table></figure><p>之后，我们查看<code>/var/log/messages</code>，可以获取到程序的crash信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /var/log/messages</span><br><span class="line"></span><br><span class="line">May  8 23:52:15 localhost kernel: [1465653.941751] segfault[6805]: segfault at 0 ip 0000000000400916 sp 00007ffe2f9ec820 error 4 in segfault[400000+1000]</span><br></pre></td></tr></table></figure><p>其中，<code>segfault at</code>为引起故障的地址，<code>ip</code>为指令的内存地址，<code>sp</code>为堆栈指针地址, 及栈顶指针。</p><p>通过<code>addr2line</code>指令，我们就可以把<code>ip</code>映射到程序代码的crash位置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">addr2line -Cfie ./segfault 0000000000400916</span><br><span class="line">std::string::_M_data() const</span><br><span class="line">/usr/lib/gcc/x86_64-redhat-linux/4.4.6/../../../../include/c++/4.4.6/bits/basic_string.h:278</span><br><span class="line">std::string::_M_rep() const</span><br><span class="line">/usr/lib/gcc/x86_64-redhat-linux/4.4.6/../../../../include/c++/4.4.6/bits/basic_string.h:286</span><br><span class="line">std::string::size() const</span><br><span class="line">/usr/lib/gcc/x86_64-redhat-linux/4.4.6/../../../../include/c++/4.4.6/bits/basic_string.h:629</span><br><span class="line">operator&lt;&lt; &lt;char, std::char_traits&lt;char&gt;, std::allocator&lt;char&gt; &gt;</span><br><span class="line">/usr/lib/gcc/x86_64-redhat-linux/4.4.6/../../../../include/c++/4.4.6/bits/basic_string.h:2503</span><br><span class="line">main</span><br><span class="line">main.cpp:12</span><br></pre></td></tr></table></figure><p><code>addr2line</code>用于将函数地址解析为函数名，其中:</p><ul><li><code>-C</code>：将低级别的符号名解码为用户级别的名字。</li><li><code>-f</code>：用于在显示文件名、行号输出信息的同时显示函数名信息。</li><li><code>-i</code>：如果需要转换的地址是一个内联函数，则还将打印返回第一个非内联函数的信息。</li><li><code>-e</code>：用于指定需要转换地址的可执行文件名。</li></ul><p>通过上述信息，我们就可以定位到程序crash在了main函数里，crash位置为<code>main.cpp:12</code>，就是我们访问空指针的位置，从而帮助我们定位代码问题。</p>]]></content>
    
    
    <summary type="html">没有core文件时，如何根据系统日志定位进程crash原因？</summary>
    
    
    
    
    <category term="cpp" scheme="http://example.com/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>boost内存池原理</title>
    <link href="http://example.com/2022/02/24/boost%E5%86%85%E5%AD%98%E6%B1%A0%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2022/02/24/boost%E5%86%85%E5%AD%98%E6%B1%A0%E5%8E%9F%E7%90%86/</id>
    <published>2022-02-24T11:42:21.000Z</published>
    <updated>2022-02-24T12:30:36.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><img src="/images/boost/PODptr1.png" width="40%" height="40%"><p><code>boost::pool</code>内存池每次申请内存时，会申请一大块内存，作为1个<code>block</code>，在代码中使用<code>PODptr</code>来表示。<br>每个<code>PODptr</code>包含3部分组成：<br>1.可用内存区，由多块<code>chunk</code>组成，每一块<code>chunk</code>就是一块可用的内存块。<br>2.指向下一块<code>PODptr</code>的指针。<br>3.下一块<code>PODptr</code>的大小。<br>若当前<code>PODptr</code>为最后一块内存，则指针为空。</p><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p><img src="/images/boost/PODptr2.png" alt="PODptr2"><br>在<code>PODptr</code>中，每一块未分配的<code>chunk</code>，其前<code>sizeof(void*)</code>个字节，会作为一个指针，指向下一块未分配的<code>chunk</code>。<br>因此，<code>chunk</code>的最小大小为<code>sizeof(void*)</code>。<br><img src="/images/boost/PODptr3.png" alt="PODptr3"><br>每一块<code>PODptr</code>中，最后一块未分配<code>chunk</code>，其头部指针会指向下一块<code>block</code>的第一块未分配<code>chunk</code>，所有的未分配<code>chunk</code>会构成1个链表。<br><code>boost::pool</code>中会维护1个<code>first</code>指针，指向链表中的第一块未分配<code>chunk</code>。<br><img src="/images/boost/PODptr4.png" alt="PODptr4"><br>同时，所有的<code>PODptr</code>也会构成1个链表。<br><code>boost::pool</code>中为维护1个<code>list</code>指针，指向链表中的第一块<code>PODptr</code>。<br>因此，<code>boost::pool</code>中总共会维护2个链表，分别为头部为first的<code>chunk</code>指针，以及头部为<code>list</code>的<code>PODptr</code>指针。</p><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><h3 id="PODptr分配"><a href="#PODptr分配" class="headerlink" title="PODptr分配"></a>PODptr分配</h3><p><img src="/images/boost/PODptr5.png" alt="PODptr5"><br><code>boost::pool</code>每次申请内存时，会申请一整块连续内存，作为1个<code>PODptr</code>。<br><code>PODptr</code>中的<code>chunk</code>数量会成倍递增，初始<code>chunk</code>数量以及最大<code>chunk</code>数量可以在构造<code>boost::pool</code>时通过传递参数来指定。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">pool</span><span class="params">(<span class="keyword">const</span> size_type nrequested_size,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> size_type nnext_size = <span class="number">32</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">const</span> size_type nmax_size = <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，<code>nnext_size</code>为初始chunk数量，<code>nmax_size</code>为最大chunk数量，默认为0(即不指定)。</p><h3 id="malloc-amp-amp-ordered-malloc"><a href="#malloc-amp-amp-ordered-malloc" class="headerlink" title="malloc &amp;&amp; ordered_malloc"></a>malloc &amp;&amp; ordered_malloc</h3><p><code>boost::pool</code>有2种申请内存的方式：<code>malloc()</code>以及<code>ordered_malloc()</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> * malloc <span class="title">BOOST_PREVENT_MACRO_SUBSTITUTION</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">store</span>().<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">store</span>().malloc)();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">malloc_need_resize</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">ordered_malloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="keyword">if</span> (!<span class="built_in">store</span>().<span class="built_in">empty</span>())</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">store</span>().malloc)();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">ordered_malloc_need_resize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2种方式的共同点在于：<br><img src="/images/boost/malloc1.png" alt="malloc1"><br>都会返回<code>first</code>指针指向的<code>chunk</code>，并将<code>first</code>指针指向下一块<code>chunk</code>。<br>若当前已无可用的<code>chunk</code>，则会申请一块新的<code>PODptr</code>，并返回第一块<code>chunk</code>。<br>不同点在于：<br><img src="/images/boost/malloc2.png" alt="malloc2"><br><code>malloc()</code>不会对新构建的<code>PODptr</code>进行排序，而是会直接把新的<code>PODptr</code>作为链表的头部。<br><img src="/images/boost/malloc3.png" alt="malloc3"><br>而<code>ordered_malloc()</code>会按照内存地址，对新构建的<code>PODptr</code>进行排序，以保证<code>PODptr</code>链表的有序性。</p><h2 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h2><p>内存回收同样提供了2个接口：<code>free()</code>和<code>ordered_free()</code>。<br>区别在于：<br><code>free()</code>接口，会把回收的内存直接作为链表的头部，其头部指针指向链表原来的的头部，这种回收方式，会直接破坏掉链表的有序性。<br><img src="/images/boost/free1.png" alt="free1"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> free <span class="title">BOOST_PREVENT_MACRO_SUBSTITUTION</span><span class="params">(<span class="keyword">void</span> * <span class="keyword">const</span> chunk)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//! Free a chunk.</span></span><br><span class="line">  <span class="comment">//! \pre chunk was previously returned from a malloc() referring to the same free list.</span></span><br><span class="line">  <span class="comment">//! \post !empty()</span></span><br><span class="line">   <span class="function">BOOST_POOL_VALIDATE_INTERNALS</span></span><br><span class="line"><span class="function">  <span class="title">nextof</span><span class="params">(chunk)</span> </span>= first;</span><br><span class="line">  first = chunk;</span><br><span class="line">  BOOST_POOL_VALIDATE_INTERNALS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>ordered_free()</code>接口，在回收内存时，会通过遍历链表，来对回收的内存进行插入排序，以保证链表的有序性。<br>因此<code>ordered_free()</code>会有<code>O(n)</code>的时间复杂度，而<code>free()</code>只有<code>O(1)</code>的时间复杂度。<br><img src="/images/boost/free2.png" alt="free2"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ordered_free</span><span class="params">(<span class="keyword">void</span> * <span class="keyword">const</span> chunk)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//! This (slower) implementation of &#x27;free&#x27; places the memory</span></span><br><span class="line">  <span class="comment">//!  back in the list in its proper order.</span></span><br><span class="line">  <span class="comment">//! \pre chunk was previously returned from a malloc() referring to the same free list</span></span><br><span class="line">  <span class="comment">//! \post !empty().</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Find where &quot;chunk&quot; goes in the free list</span></span><br><span class="line">   BOOST_POOL_VALIDATE_INTERNALS</span><br><span class="line">  <span class="keyword">void</span> * <span class="keyword">const</span> loc = <span class="built_in">find_prev</span>(chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Place either at beginning or in middle/end.</span></span><br><span class="line">  <span class="keyword">if</span> (loc == <span class="number">0</span>)</span><br><span class="line">    (free)(chunk);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">nextof</span>(chunk) = <span class="built_in">nextof</span>(loc);</span><br><span class="line">    <span class="built_in">nextof</span>(loc) = chunk;</span><br><span class="line">  &#125;</span><br><span class="line">  BOOST_POOL_VALIDATE_INTERNALS</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="内存释放"><a href="#内存释放" class="headerlink" title="内存释放"></a>内存释放</h2><p>由于<code>boost::pool</code>在申请内存时，是申请的一整块<code>PODptr</code>。<br>因此在释放内存时，只能对一整块<code>PODptr</code>进行释放，不能对单独的<code>chunk</code>进行内存释放。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> pool&lt;UserAllocator&gt;::<span class="built_in">release_memory</span>()</span><br><span class="line"><span class="keyword">bool</span> pool&lt;UserAllocator&gt;::<span class="built_in">purge_memory</span>()</span><br></pre></td></tr></table></figure><p><code>boost::pool</code>提供了上述2个释放内存的接口，区别在于：<br><code>release_memory()</code>只会释放未分配的<code>PODptr</code>。<br><code>purge_memory()</code>会释放掉所有的<code>PODptr</code>。<br><img src="/images/boost/release1.png" alt="release1"></p><p>我们以如图所示的case来分析<code>release_memory()</code>的过程。<br>其中，<code>PODptr1</code>和<code>PODptr3</code>均有<code>chunk</code>还未回收，<code>PODptr2</code>中的<code>chunk</code>是完整的。<br>在释放内存的过程中，会通过<code>list</code>指针以及<code>PODptr</code>的<code>ptr</code>指针，来遍历所有的<code>PODptr</code>。<br>通过遍历<code>PODptr</code>中未分配的<code>chunk</code>是否连续，来确认<code>PODptr</code>中的<code>chunk</code>是否完整。<br><img src="/images/boost/release2.png" alt="release2"><br>当发现1个完整的<code>PODptr</code>时，便会修改前置<code>PODptr</code>的指针，将这个<code>PODptr</code>从链表中剥离出来，并进行内存释放操作。</p><p>因此，如果想通过<code>release_memory()</code>来释放空闲的<code>PODptr</code>，必须保证链表的有序性，即：<br>必须通过<code>ordered_malloc()</code>和<code>ordered_free()</code>来进行内存的申请和回收。<br>但是<code>ordered_free()</code>有着<code>O(n)</code>的时间复杂度，其性能远低于<code>free()</code>，因此需要根据实际使用场景去进行取舍了，必要的时候，需要再进行封装优化。</p>]]></content>
    
    
    <summary type="html">boost内存池的原理解析</summary>
    
    
    
    
    <category term="boost" scheme="http://example.com/tags/boost/"/>
    
  </entry>
  
  <entry>
    <title>linux指令学习</title>
    <link href="http://example.com/2021/08/01/linux%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2021/08/01/linux%E6%8C%87%E4%BB%A4%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-08-01T03:59:01.000Z</published>
    <updated>2022-02-24T11:59:11.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-1指令学习"><a href="#1-1指令学习" class="headerlink" title="1.1指令学习"></a>1.1指令学习</h1><h3 id="单引号、双引号、反引号的区别"><a href="#单引号、双引号、反引号的区别" class="headerlink" title="单引号、双引号、反引号的区别"></a>单引号、双引号、反引号的区别</h3><ul><li>单引号和双引号都为字符串，但是单引号剥夺其中所有字符的特殊含义，双引号中的’$(参数替换)’和’`(命令替换)’是例外。</li><li>反引号等价于$()，其中的内容会被当作命令执行一遍，再将结果加入到原命令中重新执行。</li></ul><h3 id="、-、-的区别"><a href="#、-、-的区别" class="headerlink" title="()、[]、{}的区别"></a>()、[]、{}的区别</h3><ul><li>()把command group放在subshell中执行</li><li>{}则是在同一个shell内完成</li><li>[]用于比较，放在if、while语句里，通常情况下，使用[[]]，不使用[]，可以防止脚本中的很多逻辑错误</li></ul><h3 id="gt-与-gt-gt-的区别"><a href="#gt-与-gt-gt-的区别" class="headerlink" title="&gt;与&gt;&gt;的区别"></a>&gt;与&gt;&gt;的区别</h3><ul><li>&gt;为覆盖原有内容</li><li>&gt;&gt;为追加原有内容</li><li>&lt;输入改为从文件或者其它设备获取</li></ul><h3 id="source-sh-bash-的区别"><a href="#source-sh-bash-的区别" class="headerlink" title="source sh bash ./ 的区别"></a>source sh bash ./ 的区别</h3><h4 id="source"><a href="#source" class="headerlink" title="source"></a>source</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> a.sh</span></span><br></pre></td></tr></table></figure><ul><li>在当前shell内去读取、执行a.sh，而a.sh不需要有”执行权限”</li><li>source命令可以简写为”.”</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> . a.sh</span></span><br></pre></td></tr></table></figure><h4 id="sh-bash"><a href="#sh-bash" class="headerlink" title="sh/bash"></a>sh/bash</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sh a.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> bash a.sh</span></span><br></pre></td></tr></table></figure><p>都是打开一个subshell去读取、执行a.sh，而a.sh不需要有”执行权限”<br>通常在subshell里运行的脚本里设置变量，不会影响到父shell的。</p><h4 id=""><a href="#" class="headerlink" title="./"></a>./</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./a.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash">bash: ./a.sh: 权限不够</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod +x a.sh</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./a.sh</span></span><br></pre></td></tr></table></figure><p>打开一个subshell去读取、执行a.sh，但a.sh需要有”执行权限”<br>可以用chmod +x添加执行权限</p><h3 id="-1"><a href="#-1" class="headerlink" title="|"></a>|</h3><blockquote><p>将左侧命令的标准输出转换为标准输入，提供给右侧命令作为参数。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/passwd | grep root</span></span><br></pre></td></tr></table></figure><p>等同于</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> grep root /etc/passwd</span></span><br></pre></td></tr></table></figure><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><blockquote><p>查看进程状态</p></blockquote><p>常用指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">显示进程信息</span></span><br><span class="line">ps -A</span><br><span class="line"><span class="meta">#</span><span class="bash">显示root进程用户信息</span></span><br><span class="line">ps -u root</span><br><span class="line"><span class="meta">#</span><span class="bash">显示所有命令，连带命令行</span></span><br><span class="line">ps -ef</span><br><span class="line"><span class="meta">#</span><span class="bash">显示所有包含其他使用者的行程</span></span><br><span class="line">ps -aux</span><br></pre></td></tr></table></figure><h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><blockquote><p>退出当前shell进程，并返回一个退出状态，使用<code>$?</code>可以接收这个退出状态。接受一个整数值作为参数，代表退出状态，默认为0，退出状态只能是一个介于0～255之间的整数，只有0表示成功，其它值表示失败。</p></blockquote><h3 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h3><blockquote><p>显示网络状态</p></blockquote><p>常用指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">显示监听的套接口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> netstat -l</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看所有网络端口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> netstat -nap</span></span><br><span class="line"><span class="meta">#</span><span class="bash">显示udp连接情况</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> netstat -nu</span></span><br><span class="line"><span class="meta">#</span><span class="bash">显示UDP端口号的使用情况</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> netstat -apu</span></span><br><span class="line"><span class="meta">#</span><span class="bash">显示网卡列表</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> netstat -i</span></span><br></pre></td></tr></table></figure><h3 id="lsof"><a href="#lsof" class="headerlink" title="lsof"></a>lsof</h3><blockquote><p>列出当前系统打开的文件，用于查看进程打开的文件、端口。</p></blockquote><p>常用指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">查看某个用户打开的文件信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lsof -u username</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看某个程序进程所打开的文件信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lsof -c mysql</span></span><br><span class="line"><span class="meta">#</span><span class="bash">通过某个进程号显示该进程打开的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lsof -p pid</span></span><br><span class="line"><span class="meta">#</span><span class="bash">列出所有的网络连接</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lsof -i</span></span><br><span class="line"><span class="meta">#</span><span class="bash">列出所有tcp 网络连接信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lsof -i tcp</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看端口的使用情况</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lsof -i :port</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看某个用户的所有活跃的网络端口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lsof -a -u username -i</span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看进程所打开的所有IPV4 network files</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> lsof -i 4 -a -p pid</span></span><br></pre></td></tr></table></figure><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><blockquote><p>处理、编辑文本文件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sed [-hnV] [-e&lt;script&gt;] [-f&lt;script文件&gt;] [文本文件]</span></span><br></pre></td></tr></table></figure><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><ul><li>-h显示帮助</li><li>-n显示script处理之后的结果</li><li>-V显示版本信息</li><li>-i<script>以选项中指定的script来处理输入的文本文件，并将结果保存在文件中</li><li>-e<script>以选项中指定的script来处理输入的文本文件，并将结果输出到标准输出</li><li>-f&lt;script文件&gt;以选项中指定的script文件来处理输入的文本文件<h4 id="动作说明"><a href="#动作说明" class="headerlink" title="动作说明"></a>动作说明</h4></li><li>a 新增(目前的下一行)</li><li>c 取代(行级别)</li><li>d 删除</li><li>i 插入(目前的上一行)</li><li>p 打印</li><li>s 取代(内容级别)</li><li>q 退出</li></ul><p>demo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">在第3行前新增内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed -i <span class="string">&quot;3a\test4&quot;</span> ./test.cfg</span></span><br><span class="line"><span class="meta">#</span><span class="bash">在第3行后新增内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed -i <span class="string">&quot;3i\test4&quot;</span> ./test.cfg</span></span><br><span class="line"><span class="meta">#</span><span class="bash">在内容为<span class="string">&quot;test4&quot;</span>的匹配前新增内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed -i <span class="string">&quot;/test4/i\test5&quot;</span> ./test.cfg</span></span><br><span class="line"><span class="meta">#</span><span class="bash">在内容为<span class="string">&quot;test4&quot;</span>的匹配行后新增内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed -i <span class="string">&quot;/test4/a\test5&quot;</span> ./test.cfg</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除第1行至第2行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed -i <span class="string">&quot;1,2d&quot;</span> ./test.cfg</span></span><br><span class="line"><span class="meta">#</span><span class="bash">删除第5行至最后一行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed -i <span class="string">&#x27;5,$d&#x27;</span> ./test.cfg</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将第1行至第4行的内容替换</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed -i <span class="string">&quot;1,4c newtest&quot;</span> ./test.cfg</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将第1行至第4行的内容打印出来</span></span><br><span class="line"><span class="meta">$</span><span class="bash">sed -n <span class="string">&quot;1,4p&quot;</span> ./test.cfg</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将newtest替换为replacetest(第一次替换)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed -i <span class="string">&quot;s/newtest/replacetest/&quot;</span> ./test.cfg</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将newtest替换为replacetest(全部替换)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed -i <span class="string">&quot;s/newtest/replacetest/g&quot;</span> ./test.cfg</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将内容中包含replace的行打印出来</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed -n <span class="string">&quot;/replace/p&quot;</span> ./test.cfg</span></span><br><span class="line"><span class="meta">#</span><span class="bash">将内容中包含replace的行删除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed -i <span class="string">&quot;/replace/d&quot;</span> ./test.cfg</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 搜寻内容并执行指令(将内容中包含test1的行搜寻出来，并将<span class="built_in">test</span>替换为replace)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed -i <span class="string">&quot;/test1/&#123;s/test/replace/&#125;&quot;</span> ./test.cfg</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 多点编辑，先删除前4行，再将<span class="built_in">test</span>替换为new</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sed -e <span class="string">&quot;1,4d&quot;</span> -e <span class="string">&quot;s/test/new/g&quot;</span> ./test.cfg</span></span><br></pre></td></tr></table></figure><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><blockquote><p>处理文本文件</p></blockquote><p>用法一</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">行匹配语句 awk <span class="string">&#x27;&#x27;</span> 只能用单引号</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">&#x27;&#123;[pattern] action&#125;&#x27;</span> &#123;filenames&#125;</span></span><br><span class="line"><span class="meta">#</span><span class="bash">每行按空格或TAB分割，输出文本中的1、4项</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">&#x27;&#123;print $1,$4&#125;&#x27;</span> log.txt</span></span><br></pre></td></tr></table></figure><p>用法二</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">-F相当于内置变量FS, 指定分割字符</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk -F</span></span><br><span class="line"><span class="meta">#</span><span class="bash">使用<span class="string">&quot;,&quot;</span>分割</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk -F, <span class="string">&#x27;&#123;print $1,$2&#125;&#x27;</span> log.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用多个分隔符.先使用空格分割，然后对分割结果再使用<span class="string">&quot;,&quot;</span>分割</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk -F <span class="string">&#x27;[ ,]&#x27;</span>  <span class="string">&#x27;&#123;print $1,$2,$5&#125;&#x27;</span>   log.txt</span></span><br></pre></td></tr></table></figure><p>用法三</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置变量</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk -v</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk -va=1 <span class="string">&#x27;&#123;print $1,$1+a&#125;&#x27;</span> log.txt</span></span><br></pre></td></tr></table></figure><p>用法四</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> awk -f &#123;awk脚本&#125; &#123;文件名&#125;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk -f cal.awk log.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash">过滤第一列大于2的行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">&#x27;$1&gt;2&#x27;</span> log.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash">过滤第一列等于2的行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">&#x27;$1==2 &#123;print $1,$3&#125;&#x27;</span> log.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash">过滤第一列大于2并且第二列等于<span class="string">&#x27;Are&#x27;</span>的行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">&#x27;$1&gt;2 &amp;&amp; $2==&quot;Are&quot; &#123;print $1,$2,$3&#125;&#x27;</span> log.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash">使用正则，字符串匹配</span></span><br><span class="line"><span class="meta">#</span><span class="bash">输出第二列包含 <span class="string">&quot;th&quot;</span>，并打印第二列与第四列</span></span><br><span class="line"><span class="meta">#</span><span class="bash">~ 表示模式开始。// 中是模式。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">&#x27;$2 ~ /th/ &#123;print $2,$4&#125;&#x27;</span> log.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash">取反</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">&#x27;$2 !~ /th/ &#123;print $2,$4&#125;&#x27;</span> log.txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash">输出包含 <span class="string">&quot;re&quot;</span> 的行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> awk <span class="string">&#x27;/re/ &#x27;</span> log.txt</span></span><br></pre></td></tr></table></figure><h3 id="xargs"><a href="#xargs" class="headerlink" title="xargs"></a>xargs</h3><blockquote><p>将标准输入转为命令行参数，大多数命令（比如rm、mkdir、ls）与管道一起使用时，都需要xargs将标准输入转为命令行参数</p></blockquote><p>用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xargs [-options] [<span class="built_in">command</span>]</span></span><br></pre></td></tr></table></figure><p>常用指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> | xargs <span class="built_in">echo</span></span></span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><p>单独使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">xargs后面的命令默认是<span class="built_in">echo</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xargs</span></span><br><span class="line"><span class="meta">#</span><span class="bash">等同于</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xargs <span class="built_in">echo</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">输入xargs按下回车以后，命令行就会等待用户输入，作为标准输入，按下Ctrl d，表示输入结束</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xargs</span></span><br><span class="line">hello (Ctrl + d)</span><br><span class="line">hello</span><br><span class="line"><span class="meta">$</span><span class="bash"> xargs find -name</span></span><br><span class="line">&quot;*.txt&quot; (Ctrl + d)</span><br><span class="line">./foo.txt</span><br><span class="line">./hello.txt</span><br></pre></td></tr></table></figure><p>-d 参数与分隔符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">默认情况下，xargs将换行符和空格作为分隔符，把标准输入分解成一个个命令行参数</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;one two three&quot;</span> | xargs mkdir</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-d参数可以更改分隔符</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">&quot;a\tb\tc&quot;</span> | xargs -d <span class="string">&quot;\t&quot;</span> <span class="built_in">echo</span></span></span><br><span class="line">a b c</span><br></pre></td></tr></table></figure><p>-p 参数，-t 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">-p参数打印出要执行的命令，询问用户是否要执行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;one two three&#x27;</span> | xargs -p touch</span></span><br><span class="line">touch one two three ?...</span><br><span class="line"><span class="meta">#</span><span class="bash">-t参数则是打印出最终要执行的命令，然后直接执行，不需要用户确认。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&#x27;one two three&#x27;</span> | xargs -t rm</span></span><br><span class="line">rm one two three</span><br></pre></td></tr></table></figure><p>-0 参数与 find 命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">由于xargs默认将空格作为分隔符，所以不太适合处理文件名，因为文件名可能包含空格。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">find命令有一个特别的参数-print0，指定输出的文件列表以null分隔。然后，xargs命令的-0参数表示用null当作分隔符。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find /path -<span class="built_in">type</span> f -print0 | xargs -0 rm</span></span><br><span class="line"><span class="meta">#</span><span class="bash">上面命令删除/path路径下的所有文件。由于分隔符是null，所以处理包含空格的文件名，也不会报错。</span></span><br></pre></td></tr></table></figure><p>-L 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果标准输入包含多行，-L参数指定多少行作为一个命令行参数。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xargs -L 1 find -name</span></span><br><span class="line">&quot;*.txt&quot;</span><br><span class="line">./foo.txt</span><br><span class="line">./hello.txt</span><br><span class="line">&quot;*.md&quot;</span><br><span class="line">./README.md</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> -e <span class="string">&quot;a\nb\nc&quot;</span> | xargs -L 1 <span class="built_in">echo</span></span></span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br></pre></td></tr></table></figure><p>-n 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">-n参数指定每次将多少项，作为命令行参数。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> xargs -n 1 find -name</span></span><br><span class="line"><span class="meta">#</span><span class="bash">上面命令指定将每一项（-n 1）标准输入作为命令行参数，分别执行一次命令（find -name）。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> &#123;0..9&#125; | xargs -n 2 <span class="built_in">echo</span></span></span><br><span class="line">0 1</span><br><span class="line">2 3</span><br><span class="line">4 5</span><br><span class="line">6 7</span><br><span class="line">8 9</span><br></pre></td></tr></table></figure><p>-I 参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果xargs要将命令行参数传给多个命令，可以使用-I参数。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-I指定每一项命令行参数的替代字符串。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat foo.txt</span></span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat foo.txt | xargs -I file sh -c <span class="string">&#x27;echo file; mkdir file&#x27;</span></span></span><br><span class="line">one </span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span> </span><br><span class="line">one two three</span><br><span class="line"><span class="meta">#</span><span class="bash">上面代码中，foo.txt是一个三行的文本文件。我们希望对每一项命令行参数，执行两个命令（<span class="built_in">echo</span>和mkdir），使用-I file表示file是命令行参数的替代字符串。执行命令时，具体的参数会替代掉<span class="built_in">echo</span> file; mkdir file里面的两个file。</span></span><br></pre></td></tr></table></figure><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><blockquote><p>disk usage，用于显示目录或文件的大小。</p></blockquote><p>用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">-b，以byte为单位</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-k，以1024bytes为单位</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-m，以1MB为单位</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-s或--summarize 仅显示总计。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--exclude=&lt;目录或文件&gt; 略过指定的目录或文件。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X &lt;文件&gt;][--block-size][--exclude=&lt;目录或文件&gt;][--max-depth=&lt;目录层数&gt;][--<span class="built_in">help</span>][--version][目录或文件]</span></span><br></pre></td></tr></table></figure><p>常用指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> du -h --map-depth=1 [目录]</span></span><br></pre></td></tr></table></figure><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><blockquote><p>disk free，用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。</p></blockquote><p>用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> df [选项]... [FILE]...</span></span><br></pre></td></tr></table></figure><p>常用指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df</span><br></pre></td></tr></table></figure><h3 id="perf"><a href="#perf" class="headerlink" title="perf"></a>perf</h3><blockquote><p>抓取程序的运行堆栈</p></blockquote><p>用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> perf record -F [频率] -p [pid] -- sleep [时间]</span></span><br></pre></td></tr></table></figure><p>生成火焰图</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成折叠后的调用栈</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> perf script -i perf.data &amp;&gt; perf.unfold</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成火焰图</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./stackcollapse-perf.pl perf.unfold &amp;&gt; perf.folded</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./flamegraph.pl perf.folded &gt; perf.svg</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> perf script | ./stackcollapse-perf.pl | ./flamegraph.pl &gt; process.svg</span></span><br></pre></td></tr></table></figure><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><blockquote><p>显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer。</p></blockquote><p>用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> free -k</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> free -m</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> free -g</span></span><br></pre></td></tr></table></figure><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><blockquote><p>在指定目录下查找文件。</p></blockquote><p>用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find . -name <span class="string">&quot;*.cpp&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">正则表达式需要匹配完整路径</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -regex <span class="string">&quot;\./[a-z].*&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h3><blockquote><p>抓包分析工具，打印所有经过网络接口的数据包的头信息。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">-a：尝试将网络和广播地址转换成名称；</span><br><span class="line">-c&lt;数据包数目&gt;：收到指定的数据包数目后，就停止进行倾倒操作；</span><br><span class="line">-d：把编译过的数据包编码转换成可阅读的格式，并倾倒到标准输出；</span><br><span class="line">-dd：把编译过的数据包编码转换成C语言的格式，并倾倒到标准输出；</span><br><span class="line">-ddd：把编译过的数据包编码转换成十进制数字的格式，并倾倒到标准输出；</span><br><span class="line">-e：在每列倾倒资料上显示连接层级的文件头；</span><br><span class="line">-f：用数字显示网际网络地址；</span><br><span class="line">-F&lt;表达文件&gt;：指定内含表达方式的文件；</span><br><span class="line">-i&lt;网络界面&gt;：使用指定的网络截面送出数据包；</span><br><span class="line">-l：使用标准输出列的缓冲区；</span><br><span class="line">-n：不把主机的网络地址转换成名字；</span><br><span class="line">-N：不列出域名；</span><br><span class="line">-O：不将数据包编码最佳化；</span><br><span class="line">-p：不让网络界面进入混杂模式；</span><br><span class="line">-q ：快速输出，仅列出少数的传输协议信息；</span><br><span class="line">-r&lt;数据包文件&gt;：从指定的文件读取数据包数据；</span><br><span class="line">-s&lt;数据包大小&gt;：设置每个数据包的大小；</span><br><span class="line">-S：用绝对而非相对数值列出TCP关联数；</span><br><span class="line">-t：在每列倾倒资料上不显示时间戳记；</span><br><span class="line">-tt： 在每列倾倒资料上显示未经格式化的时间戳记；</span><br><span class="line">-T&lt;数据包类型&gt;：强制将表达方式所指定的数据包转译成设置的数据包类型；</span><br><span class="line">-v：详细显示指令执行过程；</span><br><span class="line">-vv：更详细显示指令执行过程；</span><br><span class="line">-x：用十六进制字码列出数据包资料；</span><br><span class="line">-w&lt;数据包文件&gt;：把数据包数据写入指定的文件。</span><br></pre></td></tr></table></figure><p>常用指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">指定网卡监听</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i eth1</span></span><br></pre></td></tr></table></figure><blockquote><p>监视指定主机的数据包</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">抓取指定主机的数据包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump host 127.0.0.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">抓取主机210.27.48.1 和主机210.27.48.2 或210.27.48.3的通信</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump host 210.27.48.1 and \(210.27.48.2 or 210.27.48.3 \)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">获取主机210.27.48.1除了和主机210.27.48.2之外所有主机通信的ip包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump ip host 210.27.48.1 and ! 210.27.48.2</span></span><br><span class="line"><span class="meta">#</span><span class="bash">获取主机hostname发送的所有数据</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i eth0 src host hostname</span></span><br><span class="line"><span class="meta">#</span><span class="bash">获取所有送到主机hostname的数据包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i eth0 dst host hostname</span></span><br></pre></td></tr></table></figure><blockquote><p>获取指定主机和端口的数据包</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">获取主机210.27.48.1接收或发出的telnet包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump tcp port 23 host 210.27.48.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">对本机的udp 123 端口进行监视</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump udp port 123</span></span><br></pre></td></tr></table></figure><blockquote><p>常用抓包指令</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">tcp抓包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -iany dst port &lt;port&gt; -X</span></span><br><span class="line"><span class="meta">#</span><span class="bash">udp抓包</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tcpdump -i lo udp port &lt;port&gt; -X</span></span><br></pre></td></tr></table></figure><h3 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h3><blockquote><p>用于请求Web服务器，客户端（client）的URL工具的意思。</p></blockquote><blockquote><p>不带任何参数时，curl就是发出GET请求。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl https://www.example.com</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-b</code>参数用来向服务器发送Cookie。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">生成一个标头Cookie: foo=bar，向服务器发送一个名为foo、值为bar的 Cookie。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -b <span class="string">&#x27;foo=bar&#x27;</span> https://google.com</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -b <span class="string">&#x27;foo1=bar;foo2=bar2&#x27;</span> https://google.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash">读取本地文件cookies.txt，将其发送到服务器。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -b cookies.txt https://www.google.com</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-c</code>参数将服务器设置的 Cookie 写入一个文件。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将服务器的 HTTP 回应所设置 Cookie 写入文本文件cookies.txt。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -c cookies.txt https://www.google.com</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-d</code>参数用于发送 POST 请求的数据体。使用<code>-d</code>参数以后，HTTP 请求会自动加上标头<code>Content-Type : application/x-www-form-urlencoded</code>。并且会自动将请求转为 POST 方法，因此可以省略<code>-X POST</code>。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -d <span class="string">&#x27;login=emma＆password=123&#x27;</span> -X POST https://google.com/login</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -d <span class="string">&#x27;login=emma&#x27;</span> -d <span class="string">&#x27;password=123&#x27;</span> -X POST  https://google.com/login</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-d参数可以读取本地文本文件的数据，向服务器发送。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -d <span class="string">&#x27;@data.txt&#x27;</span> https://google.com/login</span></span><br></pre></td></tr></table></figure><blockquote><p><code>--data-urlencode</code>参数等同于<code>-d</code>，发送 POST 请求的数据体，区别在于会自动将发送的数据进行 URL 编码。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">发送的数据hello world之间有一个空格，需要进行 URL 编码。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --data-urlencode <span class="string">&#x27;comment=hello world&#x27;</span> https://google.com/login</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-e</code>参数用来设置 HTTP 的标头<code>Referer</code>，表示请求的来源。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将Referer标头设为https://google.com?q=example</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -e <span class="string">&#x27;https://google.com?q=example&#x27;</span> https://www.example.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash">-H参数可以通过直接添加标头Referer，达到同样效果。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -H <span class="string">&#x27;Referer: https://google.com?q=example&#x27;</span> https://www.example.com</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-F</code>参数用来向服务器上传二进制文件。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">给HTTP请求加上标头Content-Type: multipart/form-data，然后将文件photo.png作为file字段上传</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -F <span class="string">&#x27;file=@photo.png&#x27;</span> https://google.com/profile</span></span><br><span class="line"><span class="meta">#</span><span class="bash">指定 MIME 类型为image/png，否则curl会把MIME类型设为application/octet-stream</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -F <span class="string">&#x27;file=@photo.png;type=image/png&#x27;</span> https://google.com/profile</span></span><br><span class="line"><span class="meta">#</span><span class="bash">原始文件名为photo.png，但是服务器接收到的文件名为me.png</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -F <span class="string">&#x27;file=@photo.png;filename=me.png&#x27;</span> https://google.com/profile</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-G</code>参数用来构造 URL 的查询字符串。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">发出一个 GET 请求，实际请求的 URL 为https://google.com/search?q=kitties&amp;count=20。如果省略--G，会发出一个 POST 请求</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -G -d <span class="string">&#x27;q=kitties&#x27;</span> -d <span class="string">&#x27;count=20&#x27;</span> https://google.com/search</span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果数据需要 URL 编码，可以结合--data--urlencode参数</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -G --data-urlencode <span class="string">&#x27;comment=hello world&#x27;</span> https://www.example.com</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-H</code>参数添加 HTTP 请求的标头。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">添加 HTTP 标头Accept-Language: en-US。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -H <span class="string">&#x27;Accept-Language: en-US&#x27;</span> https://google.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash">添加两个 HTTP 标头。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -H <span class="string">&#x27;Accept-Language: en-US&#x27;</span> -H <span class="string">&#x27;Secret-Message: xyzzy&#x27;</span> https://google.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash">添加 HTTP 请求的标头是Content-Type: application/json，然后用-d参数发送 JSON 数据。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -d <span class="string">&#x27;&#123;&quot;login&quot;: &quot;emma&quot;, &quot;pass&quot;: &quot;123&quot;&#125;&#x27;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> https://google.com/login</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-i</code>参数打印出服务器回应的 HTTP 标头。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">收到服务器回应后，先输出服务器回应的标头，然后空一行，再输出网页的源码。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -i https://www.example.com</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-I</code>参数向服务器发出 HEAD 请求，然会将服务器返回的 HTTP 标头打印出来。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">输出服务器对 HEAD 请求的回应.</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -I https://www.example.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--head参数等同于-I。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --head https://www.example.com</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-k</code>参数指定跳过 SSL 检测。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">不会检查服务器的 SSL 证书是否正确。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -k https://www.example.com</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-L</code>参数会让 HTTP 请求跟随服务器的重定向。curl 默认不跟随重定向。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -L -d <span class="string">&#x27;tweet=hi&#x27;</span> https://api.twitter.com/tweet</span></span><br></pre></td></tr></table></figure><blockquote><p><code>--limit-rate</code>用来限制 HTTP 请求和回应的带宽，模拟慢网速的环境。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将带宽限制在每秒 200K 字节。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --limit-rate 200k https://google.com</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-o</code>参数将服务器的回应保存成文件，等同于<code>wget</code>命令。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将www.example.com保存成example.html。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -o example.html https://www.example.com</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-O</code>参数将服务器回应保存成文件，并将 URL 的最后部分当作文件名。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">将服务器回应保存成文件，文件名为bar.html。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -O https://www.example.com/foo/bar.html</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-s</code>参数将不输出错误和进度信息。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">发生错误，不会显示错误信息。不发生错误的话，会正常显示运行结果。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -s https://www.example.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash">不产生任何输出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -s -o /dev/null https://google.com</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-u</code>参数用来设置服务器认证的用户名和密码。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置用户名为bob，密码为12345，然后将其转为 HTTP 标头Authorization: Basic Ym9iOjEyMzQ1。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -u <span class="string">&#x27;bob:12345&#x27;</span> https://google.com/login</span></span><br><span class="line"><span class="meta">#</span><span class="bash">识别 URL 里面的用户名和密码，将其转为上个例子里面的 HTTP 标头。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl https://bob:12345@google.com/login</span></span><br><span class="line"><span class="meta">#</span><span class="bash">只设置了用户名，执行后，curl 会提示用户输入密码。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -u <span class="string">&#x27;bob&#x27;</span> https://google.com/login</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-v</code>参数输出通信的整个过程，用于调试。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -v https://www.example.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--trace参数也可以用于调试，还会输出原始的二进制数据。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl --trace - https://www.example.com</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-x</code>参数指定 HTTP 请求的代理。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">指定 HTTP 请求通过myproxy.com:8080的 socks5 代理发出。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -x socks5://james:cats@myproxy.com:8080 https://www.example.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash">如果没有指定代理协议，默认为 HTTP。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -x james:cats@myproxy.com:8080 https://www.example.com</span></span><br></pre></td></tr></table></figure><blockquote><p><code>-X</code>参数指定 HTTP 请求的方法。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">对https://www.example.com发出 POST 请求。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -X POST https://www.example.com</span></span><br></pre></td></tr></table></figure><blockquote><p>常用指令</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">指定ip、端口</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -x ip:port <span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">指定host请求</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl -H <span class="string">&quot;Host:host&quot;</span> <span class="string">&quot;url&quot;</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一些linux指令的学习笔记</summary>
    
    
    
    
    <category term="linux" scheme="http://example.com/tags/linux/"/>
    
  </entry>
  
</feed>
